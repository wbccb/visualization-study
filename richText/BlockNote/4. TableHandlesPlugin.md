
## mouseMoveHandler

精简后的方法如下所示

- 当event.target=某一个单元格的内部元素时，比如<p>时，通过`domCellAround()`拿到`td`最外层的单元格`target`
- 然后通过`getDraggableBlockFromElement()`传入`<td>`拿到的`blockEl=<table>`
- 通过`getChildIndex()`拿到对应的单元格对应的`colIndex`和`rowIndex`



```ts
mouseMoveHandler = (event: MouseEvent) => {
    //...
    const target = domCellAround(event.target);

    const tableRect = target.tbodyNode.getBoundingClientRect();

    const blockEl = getDraggableBlockFromElement(target.domNode, this.pmView);
    if (!blockEl) {
      return;
    }
    this.tableElement = blockEl.node;

    let tableBlock;

    const pmNodeInfo = getNodeById(
      blockEl.id,
      this.editor._tiptapEditor.state.doc,
    );

    const block = nodeToBlock(
      pmNodeInfo.node,
      this.editor.schema.blockSchema,
      this.editor.schema.inlineContentSchema,
      this.editor.schema.styleSchema,
      this.editor.blockCache,
    );

    if (checkBlockIsDefaultType("table", block, this.editor)) {
      this.tablePos = pmNodeInfo.posBeforeNode + 1;
      tableBlock = block;
    }

    this.tableId = blockEl.id;
    const widgetContainer = target.domNode
      .closest(".tableWrapper")
      ?.querySelector(".table-widgets-container") as HTMLElement;

    if (target?.type === "wrapper") {
        //...
    } else {
      const colIndex = getChildIndex(target.domNode);
      const rowIndex = getChildIndex(target.domNode.parentElement!);
      const cellRect = target.domNode.getBoundingClientRect();
      //...

      this.state = {
        show: true,
        showAddOrRemoveColumnsButton:
          colIndex === tableBlock.content.rows[0].cells.length - 1,
        showAddOrRemoveRowsButton:
          rowIndex === tableBlock.content.rows.length - 1,
        referencePosTable: tableRect,

        block: tableBlock,
        draggingState: undefined,
        referencePosCell: cellRect,
        colIndex: colIndex,
        rowIndex: rowIndex,

        widgetContainer,
      };
    }
    this.emitUpdate();

    return false;
  };
```

### domCellAround

从当前的`target`向上寻找直到找到`<td>`元素或者直接找到原顶层元素tableWrapper

```ts
function domCellAround(target: Element) {
  let currentTarget: Element | undefined = target;
  while (
    currentTarget &&
    currentTarget.nodeName !== "TD" &&
    currentTarget.nodeName !== "TH" &&
    !currentTarget.classList.contains("tableWrapper")
  ) {
    if (currentTarget.classList.contains("ProseMirror")) {
      return undefined;
    }
    const parent: ParentNode | null = currentTarget.parentNode;

    if (!parent || !(parent instanceof Element)) {
      return undefined;
    }
    currentTarget = parent;
  }

  return currentTarget.nodeName === "TD" || currentTarget.nodeName === "TH"
    ? {
        type: "cell",
        domNode: currentTarget,
        tbodyNode: currentTarget.closest("tbody"),
      }
    : {
        type: "wrapper",
        domNode: currentTarget,
        tbodyNode: currentTarget.querySelector("tbody"),
      };
}
```

### getDraggableBlockFromElement

传入`<td>`元素，不断向上寻找，最外层的元素就是`blockContainer`，也就是`<table>`的外层dom就是`blockContainer`

```ts
export function getDraggableBlockFromElement(
  element: Element,
  view: EditorView
) {
  while (
    element &&
    element.parentElement &&
    element.parentElement !== view.dom &&
    element.getAttribute?.("data-node-type") !== "blockContainer"
    ) {
    element = element.parentElement;
  }
  if (element.getAttribute?.("data-node-type") !== "blockContainer") {
    return undefined;
  }
  return { node: element as HTMLElement, id: element.getAttribute("data-id")! };
}
```